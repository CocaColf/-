---
layout: post
title: 和编译器、引擎一起理解作用域
date: 2017/8/27
categories: JavaScript
---

**作用域**

作用域就是变量的执行环境。
在对程序的每条语句进行处理的时候，有三个部分会参与，编译器、引擎、作用域。以 var a = 2;为例
首先编译器会对它进行词法分析，把它分解为词法单元，然后把词法单元生成树结构。简单地说就是为一个变量分配内存，将其命名为a。
然后引擎在运行的时候会问作用域，在当前这个区域是否有一个a，如果存在，那么就拿来使用（赋值），否则就继续查找。如果在最后都没有查找到，那么引擎就会抛出一个异常。

**变量的查找**

变量的查找有LHS查询和RHS查询，变量在赋值的左边则是LHS查询，否则就是RHS查询。

```js
function foo(a) {
	console.log(a);
}
foo(2);
```

在上面这个程序里，既有LHS查询也有RHS查询，首先引擎会执行 foo(2) ，在这个有个隐式的LHS查询，即 a = 2，然后引擎会去找编译器对这个a的声明，在foo（）函数里找到了，然后对a进行RHS查询，最后对console.log(a)进行RHS引用。

**作用域的嵌套**

当一个块或者函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。因此在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域里找，找到最近的那个声明。

```js
function foo(a) {
	console.log(a + b);
}
var b = 2;
foo(2);
```

引擎在执行foo(2)时首先会在它的作用域里寻找a和b，但是它并不能找到b的声明，于是只能在外层去找，找到了b的声明，于是就愉快的完成执行。

**词法作用域**

词法作用域就是定义在词法阶段的作用域。词法作用域是在写代码的时候把变量和块的作用域写在哪里决定的。

```js
function foo(a) {
	var b = a * 2;
    function bar(c) {
    	console.log(a, b, c);
    }
    bar(b * 3);
}
foo(2);
```

这里有三个作用域嵌套：

+ 全局作用域，标识符为foo
+ foo所创建的作用域，标识符为 a,bar,b
+ bar所创建的作用域，标识符是c

引擎在执行时，会从内至外一步步查找所需要的变量，作用域会查找到第一个匹配的标识符时停止。所以如果在最内部定义外部一个同名的标识符，那么在这个内部作用域里，外部变量就会被覆盖。

**函数作用域**

对于函数中嵌套的作用域，是无法从外部作用域调用的。

```js
function foo(a) {
	var b = a * 2;
    function bar(c) {
    	console.log(a, b, c);
    }
    bar(b * 3);
}
foo(2);

bar(2);		//错误！
console.log(a, b, c)		//错误！
```

在上面这个例子里，就不能在全局环境里使用bar()
所以函数的作用就是隐藏了内部实现，只提供一个接口，外部作用域不可以访问函数内部作用域，保证了私有性。

立即执行函数表达式 IIFE

```js
var a = 2;
function foo() {
	var a = 3;
    console.log(a);
}
foo();
console.log(a);
```

像这样的代码本身并没什么问题，但是foo()实际上对全局作用域是一种污染，第一是需要显式的命名这个函数；其次必须要对它进行显式的调用。于是在这种情况下即可以使用IIFE。

```js
var a = 2;
(function foo() {
	var a = 3;
    console.log(a);
}) ();
foo();
```

注意块作用域，规避冲突

```js
function foo() {
	function bar(a) {
    	i = 3;
        console.log(a + i);
    }
    for(var i = 0; i < 10; i++) {
    	bar(i * 2);
    }
}
foo();
```

像上面这个函数实际上会进行无限循环。因为i被固定为3永远满足循环条件。当执行到bar()时，函数里面的i意外的覆盖了循环里面的i，所以解决办法就是对bar()内的i添加var声明。

**提升**

JavaScript代码并不是一行一行下来执行的。

```js
a = 2;
var a;
console.log(a);
```

按照第一反应，这个地方应该输出undefined，但实际上会输出2

```js
console.log(a);
var a = 2;
```

第一反应会输出2，但实际上输出undefined。

正确的思考方式应该是，包括函数与变量在内的所有的声明都会在任何代码被执行前进行处理。
比如 var a = 2; 实际上分为了两部，var a 和 a = 2。第一步是在编译的阶段进行的，第二个操作会在第一个操作进行完后留在原地等待执行。

所以上面的例子，第一个执行顺序是

```js
var a;
a = 2;
console.log(a);
```

第二个执行顺序是

```js
var a;
console.log(a);
a = 2;
```

总结就是，先有声明，再有赋值。声明被提升了。


```js
foo();

function foo() {
	console.log(a);
    var a = 2;
}
```

可以理解为

```js
function foo() {
	var a;
    console.log(a);
    a = 2;
}
foo();
```

像下面这种就会抛出异常

```js
foo();
var foo = function() {
	//
};
```

因为这个可以理解为

```js
var foo;
foo();
foo = function() {
	//
}
```

函数声明和变量都会被提升，但是有个细节是，函数会被先提升，然后才是变量。

```js
foo();

var foo;

function foo() {
	console.log(1);
}
foo = function() {
	console.log(2);
}
```

上面会输出1，它可以理解为

```js
//函数声明优先提升
function foo() {
	console.log(1);
}

//var foo; 是个重复声明，所以会被忽略

foo();

foo = function() {
	console.log(2);
}
```

但后面的函数会覆盖前面的（没有重载）

```js
foo();


function foo() {
	console.log(1);
}
var foo = function() {
	console.log(2);
};

function foo() {
	console.log(3);
}
```

上面会输出3，因为js没有重载

再来一个很有意思的执行顺序

```js
foo();

var a = true;

if(a) {
	function foo() { console.log("a"); }
} else {
	function foo() { console.log("b");}
}
```

按照思维这里应该输出a，因为a为真，但实际上是b。理解方式为

```js
var a;
foo();
a = true;
...
```




